#pragma rtGlobals=1		// Use modern global access method.#include "BackGrounder" 	// a background task manager to have multiple background tasks on Igor 5#include "Stages"#pragma version= 2.0		// modification date Nov 25 2010 by Jamie Boyd#pragma IgorVersion=5.05//E4050 requires the VDT XOP, not VDT2, for backwards compatability with Igor 5 on OS 9//Procedures for controlling the E4050 serial port-driven X-Y stage/focus motor controller // programmed by Pawel Kowalski (pk@sfu.ca) at the SFU machine shop.//***********************************************CONSTANTS********************************************// Because stage encoders can be mounted in various configurations, going more negative along the X-axis, e.g., may not always// correspond to going left as viewed through the microscope. And the Z-encoder may be mounted on left or right side, which could change polarity.// Therefore, we need some constants for the various directions for use with left/right, forward/back, and up/down buttons on the control panel :STATIC CONSTANT kE4050xPol = -1STATIC CONSTANT kE4050yPol = 1STATIC CONSTANT kE4050zPol = -1// variables for maximum and minimum distance from 0 for XY and Z, changes these as appropriateSTATIC CONSTANT kE4050xyMIN = -50e-03STATIC CONSTANT kE4050xyMAX = 50e-03STATIC CONSTANT kE4050zMIN = -5e-03STATIC CONSTANT kE4050zMAX = 5e-03// acceptable error for  positioning when testing to see if a position has been obtained and we can assume movement is finishedSTATIC CONSTANT kE4050err = 5e-7  // 0.5 microns // Time in seconds to wait between a read and a write, and to wait for a read to finish. // If you are getting errors while reading, maybe make this value a little bigger // Not static because we need to use it in execute statementsCONSTANT  kE4050Sleep = 0.02 // speed in m/sec needed for waiting after a move before reading, different for XY and Z axes // The stage average speed is not constant between long and short movements, of course, but this will hvae to do for now.  // You can tweak these values, listening to the XY stage or monitoring the z axis update while watching the activity indicator // The activity indicator should go black just after a move completes CONSTANT kE4050XYSpeed = 0.5e-03CONSTANT kE4050ZSpeed = 35e-06// Step sizes for XY and Z movement (resolution in meters per microstep; needed to convert values from meters to microsteps)CONSTANT  kE4050XYstepSize = 1e-07CONSTANT  kE4050ZstepSize = 2.5e-07//  Provide autoUpdate check not useful with E4050, as manual and auto commands collide. I would suggest leaving this as 0STATIC CONSTANT kE4050doAuto = 0// PID default values, as originally set by Pavel.// NOTE: z-axis is set by a simple stepper motor, and, as such, has no PID capacityCONSTANT kE4050xPIDpDef = 2000CONSTANT kE4050xPIDiDef = 5CONSTANT kE4050xPIDdDef = 2CONSTANT kE4050yPIDpDef = 2000CONSTANT kE4050yPIDiDef = 5CONSTANT kE4050yPIDdDef = 2//******************************Info for programming E4050 Commands********************************************//First character: 1 of X,Y,Z  to select an axis, N to set new 0 for X,Y,Z, or D to disable manual controls//Second character when using D to disable: 0 to disable manual conrols, 1 to enable them//Second character when using X,Y,Z to choose an axis: A to set absolute position from 0, R to set relative position  from current position,//P to get current position, H to get the Zero value, S to set the Zero value to the current position, G to go Zero, C to set PID coefficients, B to read PID coefficients//When giving a value to move the axis,  the format is plus/minus then a 6 digit number, which is in microsteps//When giving a value to set PID coeficients, the +/- sign is replaced by P, I, or D for setting each value (All PID values are positive)//All commands end with a carriage return (CR, ascii value 13)//For commands where a value is not padded (N,D, and XP, XH, etc), commands are padded with 0's plus CR  so all commands are 10 characters long//Example commands://D00000000CR - Enable the manual interface//D10000000CR - Disable the manual interface//N00000000CR - Set a new 0 position for X,Y, and Z////XA+000200CR  - put the X axis to 20 microns away from 0//XR-000200CR  - put the X axis 20 microns posterior to the current position//XG0000000CR - put the X axis to the defined Zero position (same as hitting the Go to Zero button on the box)////XS0000000CR  - set the Zero position for the X axis to the current X position (same as hitting the set Zero button on the box)////XP0000000CR - Send back to the computer the current position of the X axis in the same 6 character format plus CR//XH0000000CR - Send back to the computer the Zero position of the X axis in the same 6 character format plus CR////XCP000200CR - Sets Kp for X axis movement to 2000//XCI000200CR - Sets Ki for X axis movement to 200//XCD000200CR - Sets KD for X axis movement to 200////XBP000000CR - send back to the computer the current Kp value for X axis movement//XBI000000CR - send back to the computer the current Ki value for X axis movement//XBD000000CR - send back to the computer the current Kd value for X axis movementSTATIC CONSTANT kE4050debug = 0 // prints info to history for debugging//*******************************************************************************// make global variables.// Last modified Sep 07 2010 by Jamie BoydFunction StageInitGlobals_E4050 ()	if (!(datafolderExists ("root:packages:")))		newDataFolder root:packages:	endif 	if (!(datafolderExists ("root:packages:E4050:")))		newdatafolder root:packages:E4050	endif	// string for port name - will be set by user from popmenu which calls StageSetUpPort_E4050	string/G root:packages:E4050:thePort	// Read XY- and  Z-capability from static contstant at top of file	variable/G root:packages:E4050:hasXY = 1	variable/G root:packages:E4050:hasZ = 1	// No axial positioning	variable/G  root:packages:E4050:hasAx = 0	// Is motorized and manual lock	variable/G root:packages:E4050:hasMotor = 1	variable/G root:packages:E4050:hasLock = 1	variable/G root:packages:E4050:isLocked =0	// Has ability to change PID settings	variable/G root:packages:E4050:hasPID=1	// Serial device, not USB	variable/G root:packages:E4050:isUSB = 0	// Make a wave of unsigned bytes to create VDT outputs 	// we need a wave, not a string, because Pavel chose the command terminator character to be \r, " carriage return" , and vdt has problems with that character in a string	// 48 is ASCII 0, and 13 is ASCII return	make/o/b/u root:packages:E4050:OBPwave = {48,48,48,48,48,48,48,48,48,13} 	// make a wave of unsigned bytes to read data back from the encoder, make it bigger than we will need so it will read all available characters	make/o/b/u/n= 50 root:packages:E4050:IBPwave 	// variables for distances from 0	variable/G  root:packages:E4050:xDistanceFromzero	variable/G  root:packages:E4050:yDistanceFromzero	variable/G  root:packages:E4050:zDistanceFromzero	// step sizes for relative moves	variable/G  root:packages:E4050:xStepSize =(10 * kE4050XYstepSize)	variable/G  root:packages:E4050:yStepSize= (10 * kE4050XYstepSize)	variable/G  root:packages:E4050:zStepSize= (4 * kE4050ZstepSize)	// resolution (minimun step size)	variable/G  root:packages:E4050:xyRes = kE4050XYstepSize	variable/G  root:packages:E4050:zRes = kE4050ZstepSize	// minimum and maximum distances from 0	variable/G  root:packages:E4050:xyMIN = kE4050XYMIN	variable/G  root:packages:E4050:xyMAX = kE4050XYMAX	variable/G  root:packages:E4050:zMIN = kE4050ZMIN	variable/G  root:packages:E4050:zMAX = kE4050ZMAX	// polarity of the axes movement	variable/G  root:packages:E4050:xPol = kE4050xPol	variable/G  root:packages:E4050:yPol = kE4050yPol	variable/G  root:packages:E4050:zPol = kE4050zPol	// Autoupdate availability - not useful with E4050, as manual and auto commands collide, I recommend not using	variable/G root:packages:E4050:hasAuto =kE4050doAuto	variable/G root:packages:E4050:autoON	// variables for PID - we make z even though we can't set PID for Z, just so no errors are thrown when PID panel is created	variable/G  root:Packages:E4050:xPIDp	variable/G root:Packages:E4050:xPIDi	variable/G root:Packages:E4050:xPIDd	variable/G  root:Packages:E4050:yPIDp	variable/G root:Packages:E4050:yPIDi	variable/G root:Packages:E4050:yPIDd	variable/G  root:Packages:E4050:zPIDp	variable/G root:Packages:E4050:zPIDi	variable/G root:Packages:E4050:zPIDd	// Default PID values, from constants	variable/G  root:Packages:E4050:xPIDpDef = kE4050xPIDpDef	variable/G root:Packages:E4050:xPIDiDef = kE4050xPIDiDef	variable/G root:Packages:E4050:xPIDdDef = kE4050xPIDdDef	variable/G  root:Packages:E4050:yPIDpDef= kE4050yPIDpDef	variable/G root:Packages:E4050:yPIDiDef =  kE4050yPIDiDef	variable/G root:Packages:E4050:yPIDdDef=kE4050yPIDdDefend	//*********************************************************************************************// Opens the serial port for use with E4050// Last modified Nov 25 by Jamie BoydFunction StageSetUpPort_E4050 (thePortName)	string thePortName	string commandStr	// close the port	sprintf commandStr "VDTClosePort %s", PossiblyQuoteName(thePortName)	execute commandStr	// Open the port with the correct settings	sprintf commandStr  "VDTOperationsPort %s", PossiblyQuoteName(thePortName)	execute commandStr	sprintf commandStr "VDT /P=%s baud=9600, stopbits=1, databits=8, parity=0, in=0, out=0, buffer=4096, echo =0", PossiblyQuoteName( thePortName)	execute commandStr	sprintf commandStr "VDTOpenPort %s", PossiblyQuoteName(thePortName)	execute commandStr	StageResetIO_E4050 ()end//*********************************************************************************************// Reset I/O function for E4050, clears any pending commands// Last Modified Sep 07 2010 by Jamie BoydFunction StageResetIO_E4050 ()		BackGrounder_RemoveTask ("E4050_BkgScan()")	BackGrounder_RemoveTask ("E4050_BkgUpdate()")	NVAR isBusy = root:packages:E4050:isBusy	isBusy = 1;doUpdate	SVAR thePortName = root:packages:E4050:thePort	string commandStr	sprintf commandStr "vdt/P =%s killio", possiblyquotename (thePortName)	execute commandStr	isBusy = 0	return 0end//*******************************************************************************//Frees the Serial Portfunction StageClose_E4050(thePortName)	string thePortName		BackGrounder_RemoveTask ("E4050_BkgScan()")	BackGrounder_RemoveTask ("E4050_BkgUpdate()")	execute "VDTGetPortList"	SVAR S_VDT	if (findListItem (thePortName, S_VDT, ";") > -1)		string commandStr		sprintf commandStr "VDTClosePort %s", PossiblyQuoteName(thePortName)		execute commandStr	endif	NVAR isBusy = root:packages:E4050:isBusy	isBusy = 0end//*******************************************************************************// Gets the co-ordinates from the stage and focus, and puts them in the cooresponding global variables// Last Modified Sep 07 2010 by Jamie BoydFunction StageUpDate_E4050 (xS, yS, zS, aS)	variable &xS, &yS,&zS, &aS		// Globals	NVAR isBusy= root:packages:E4050:isBusy	if (isBusy)		return 1	endif	isBusy = 1;doupdate	NVAR lastX= root:packages:E4050:xDistanceFromzero	NVAR lastY = root:packages:E4050:yDistanceFromzero	NVAR lastZ =  root:packages:E4050:zDistanceFromzero	SVAR thePort = root:packages:E4050:thePort	WAVE/B/U OBP=  root:packages:E4050:OBPwave	WAVE/B/U IBP = root:packages:E4050:IBPwave 	variable ii, readVal 	string e4050output = ""	// Zero middle part of wave	OBP [2,8] = 48	// Set 1st character to P for get position	OBP [1]= char2num ("P")	string CommandStr	if (numtype (xS) ==0)		// set 0th character to X		OBP [0]= char2num ("X")		// write the output wave into the buffer		execute "VDTWriteBinaryWave/Q/O=(kE4050Sleep) root:packages:E4050:OBPwave"		sleep /C=-1/S kE4050Sleep		// read  the buffer into the input wave		IBP=0		execute "VDTReadBinaryWave/Q/O=(kE4050Sleep)/F=2  root:packages:E4050:IBPwave"		if (kE4050debug)			PrintE4050OutPut()		endif		// parse the read wave		// look for + or  - sign		for (ii=10;ii < 50 && (!((IBP [ii] == 43) || (IBP [ii] == 45))); ii+=1)		endfor		if (ii == 50)			print "E4050 failed to read the X value."			xS =Nan		else // read numeric characters (ASCII 48 to 57 into string			E4050outPut = num2char (IBP [ii]) 			for (ii+=1;ii < 50 && ((IBP [ii] > 47) && (IBP [ii] < 58)); ii += 1)				e4050output += num2char (IBP [ii])			endfor			readVal = str2num (E4050outPut)			if (numtype (readVal) == 0)				xS = readval * kE4050XYstepSize				lastX = xS			else				xS =Nan				print "E4050 failed to read the X value correctly. What was read was:", E4050outPut			endif		endif	endif	//Get Y	if (numtype (yS) == 0)		// set 0th character to Y		OBP [0]= char2num ("Y")		// write the output wave into the buffer		execute "VDTWriteBinaryWave/Q/O=(kE4050Sleep) root:packages:E4050:OBPwave"		sleep /C=-1/S kE4050Sleep		// read  the buffer into the input wave		IBP=0		execute "VDTReadBinaryWave/Q/O=(kE4050Sleep)/F=2  root:packages:E4050:IBPwave"		if (kE4050debug)			PrintE4050OutPut()		endif		// parse the read wave		// find + or -		for (ii=10;ii < 50 && (!((IBP [ii] == 43) || (IBP [ii] == 45))); ii+=1)		endfor		if (ii == 50)			print "E4050 failed to read the Y value."			yS =Nan		else // read numeric characters (ASCII 48 to 57 into string			E4050outPut = num2char (IBP [ii]) 			for (ii+=1;ii < 50 && ((IBP [ii] > 47) && (IBP [ii] < 58)); ii += 1)				e4050output += num2char (IBP [ii])			endfor			readVal = str2num (E4050outPut)			if (numtype (readVal) == 0)				yS = readval * kE4050XYstepSize				lastY = yS			else				yS =Nan				print "E4050 failed to read the Y value correctly. What was read was:", E4050outPut			endif		endif	endif	//Get Z	if (numtype (zS) ==0)		// set 0th character to Z		OBP [0]= char2num ("Z")		// write the output wave into the buffer		execute "VDTWriteBinaryWave/Q/O=(kE4050Sleep) root:packages:E4050:OBPwave"		sleep /C=-1/S kE4050Sleep		// read  the buffer into the input wave		IBP=0		execute "VDTReadBinaryWave/Q/O=(kE4050Sleep)/F=2  root:packages:E4050:IBPwave"		if (kE4050debug)			PrintE4050OutPut()		endif		// parse the read wave		// find + or -		for (ii=10;ii < 50 && (!((IBP [ii] == 43) || (IBP [ii] == 45))); ii+=1)		endfor		if (ii == 50)			print "E4050 failed to read the Z value."			yS =Nan		else // read numeric characters (ASCII 48 to 57 into string			E4050outPut = num2char (IBP [ii]) 			for (ii+=1;ii < 50 && ((IBP [ii] > 47) && (IBP [ii] < 58)); ii += 1)				e4050output += num2char (IBP [ii])			endfor			readVal = str2num (E4050outPut)			if (numtype (readVal) == 0)				zS = readval * kE4050ZstepSize				lastZ = zS			else				zS =Nan				print "E4050 failed to read the Z value correctly. What was read was:", E4050outPut			endif		endif	endif	isBusy = 0end//***********************************************************************************	// Stage move function for E4050 stage encoders// Last Modified Sep 07 2010 by Jamie BoydFunction StageMove_E4050 (moveType, returnWhen, xS, yS, zS, aS)	variable moveType  //  0 if requesting movement to an absolute position non-zero if requesting positive movement relative to current location,	// moveType will be -1 for negative movements, +1 for positive movements.	variable returnWhen //0 to return immediately,1 to wait until movement is finished to return, 2 to set a background task that monitors when we get there	variable  &xS, &yS, &zS, &aS // variables that will hold the retreived absolute positions		// Global for is Busy	NVAR isBusy= root:packages:E4050:isBusy	if (isBusy)		return 1	endif	isBusy = 1;doupdate	NVAR LastX = root:packages:E4050:xDistanceFromzero	NVAR LastY = root:packages:E4050:yDistanceFromzero	NVAR LastZ = root:packages:E4050:zDistanceFromzero	WAVE/b/u OBPWave = root:packages:E4050:OBPwave	WAVE/b/u IBPWave = root:packages:E4050:IBPwave	string e4050inputStr	variable ii, mv // mv is calculated distance the stage will be moving	variable/G root:packages:e4050:axisBits	NVAR axisBits = root:packages:e4050:axisBits	axisBits = 0	// request the movements	if (moveType == kStagesIsAbs )		OBPwave [1] = char2Num ("A")	else		OBPwave [1] = char2Num ("R")	endif	// X 	if (numType (xS) == 0)		axisBits += 1		// Zero middle part of wave		OBPWave [3,8] = 48		// Select X axis		OBPWave [0] = char2num ("X")		// If is relative, account for polarity		if ((moveType == kStagesIsRelPos) || (moveType == kStagesIsRelNeg))			mv = abs (xS)			NVAR polarityMult = root:packages:E4050:xPol			xS *= (polarityMult * moveType)			if (returnWhen == kStagesReturnNow)				LastX += xS			endif		else // moving to an absolute location			mv = abs (lastx - xS)			if (returnWhen == kStagesReturnNow)				LastX = xS			endif		endif		if (xS> 0)			sprintf e4050inputStr, "+%.6d", round ((xS/kE4050XYstepSize))		else			sprintf e4050inputStr, "-%.6d", round (-1*((xS/kE4050XYstepSize)))		endif		OBPWave [2,8] = char2num (e4050inputStr[p-2])		// write the output wave into the buffer		IBPWave =0		execute "VDTWriteBinaryWave/Q/O=(kE4050Sleep) root:packages:E4050:OBPwave"		// sleep depending on distance traveled		sleep /C=-1/S (kE4050Sleep + mv/kE4050XYSpeed)		// read  the buffer into the input wave just to clear buffer		execute "VDTReadBinaryWave/Q/O=(kE4050Sleep)/F=2  root:packages:E4050:IBPwave"		if (kE4050debug)			PrintE4050OutPut()		endif	endif	// Y	if (numtype (yS) == 0)		axisBits += 2		// Zero middle part of wave		OBPWave [3,8] = 48		// Select Y axis		OBPWave [0] = char2num ("Y")		// If is relative, account for polarity		if ((moveType == kStagesIsRelPos) || (moveType == kStagesIsRelNeg))			mv = abs (yS)			NVAR polarityMult = root:packages:E4050:yPol			yS *= (polarityMult * moveType)			if (returnWhen ==kStagesReturnNow)				LastY += yS			endif		else			mv = abs (lasty - yS)			if (returnWhen ==kStagesReturnNow)				LastY = yS			endif		endif		if (yS > 0)			sprintf e4050inputStr, "+%.6d", round (abs((yS/kE4050XYstepSize)))		else			sprintf e4050inputStr, "-%.6d", round (abs((yS/kE4050XYstepSize)))		endif		OBPWave [2,8] = char2num (e4050inputStr[p-2])		// write the output wave into the buffer		execute "VDTWriteBinaryWave/Q/O=(kE4050Sleep) root:packages:E4050:OBPwave"		// sleep depending on distance traveled		sleep /C=-1/S (kE4050Sleep + mv/kE4050XYSpeed)		// read  the buffer into the input wave just to clear buffer		IBPWave = 0		execute "VDTReadBinaryWave/Q/O=(kE4050Sleep)/F=2  root:packages:E4050:IBPwave"		if (kE4050debug)			PrintE4050OutPut()		endif	endif	// Z	if (numtype (zS) == 0)		axisBits += 4		// Zero middle part of wave		OBPWave [3,8] = 48		// Select Z axis		OBPWave [0] = char2num ("Z")		// If is relative, account for polarity		if ((moveType == kStagesIsRelPos) || (moveType == kStagesIsRelNeg))			mv = abs (zS)			NVAR polarityMult = root:packages:E4050:zPol			zS *= (polarityMult * moveType)			if (returnWhen ==kStagesReturnNow)				LastZ += zS			endif		else			mv = abs (lastz - zS)			if (returnWhen ==kStagesReturnNow)				lastZ = zS			endif		endif		if (zS> 0)			sprintf e4050inputStr, "+%.6d", round (abs((zS/kE4050ZstepSize)))		else			sprintf e4050inputStr, "-%.6d", round (abs((zS/kE4050ZstepSize)))		endif		OBPWave [2,8] = char2num (e4050inputStr[p-2])		// write the output wave into the buffer		execute "VDTWriteBinaryWave/Q/O=(kE4050Sleep) root:packages:E4050:OBPwave"		// sleep depending on distance traveled		sleep /C=-1/S (kE4050Sleep + mv/kE4050ZSpeed)		// read  the buffer into the input wave just to clear buffer		IBPWave =0		execute "VDTReadBinaryWave/Q/O=(kE4050Sleep)/F=2  root:packages:E4050:IBPwave"		if (kE4050debug)			PrintE4050OutPut()		endif	endif	isBusy = 0	// either set a background task or a loop to get stage coordinates	if ((returnWhen == kStagesReturnLater) || (returnWhen == kStagesReturnBkg))		sleep /C=-1/S (kE4050Sleep)		if (AxisBIts & 1)			variable/G root:packages:E4050:reqX			NVAR reqX = root:packages:E4050:reqX			if (moveType ==kStagesIsAbs)				reqX = xS			else				reqX = lastX + xS			endif			xS =1		else			xS = NaN		endif		if (AxisBIts & 2)			variable/G root:packages:E4050:reqY			NVAR reqY = root:packages:E4050:reqY			if (moveType ==kStagesIsAbs)				reqY = yS			else				reqY = lastY + yS			endif			yS =1		else			yS = Nan		endif		if (AxisBIts & 4)			variable/G root:packages:E4050:reqZ			NVAR reqZ = root:packages:E4050:reqZ			if (moveType ==kStagesIsAbs)				reqZ =zS			else				reqZ =  lastZ + zS			endif			zS=1		else			zS =NaN		endif		// set up background task or loop		if (returnWhen == kStagesReturnBkg)			BackGrounder_AddTask("E4050_BkgScan()", 15) // 4/second should be fast enough		elseif (returnWhen ==kStagesReturnLater)			do				StageUpDate_E4050 (xS, yS, zS, aS)				if (AxisBIts & 1)					if ((xS + kE4050err > reqX) && (xS - kE4050err < reqX)) 						AxisBIts -= 1						xS =NaN					else						xS=1					endif				endif				if (AxisBIts & 2)					if ((yS + kE4050err > reqY) && (yS - kE4050err < reqY)) 						AxisBits -= 2						yS=NaN					else						yS=1					endif				endif				if (AxisBIts & 4)					if ((zS + kE4050err > reqZ) && (zS - kE4050err < reqZ)) 						AxisBits -= 4						zS=NaN					else						zS=1					endif				endif			while (AxisBIts > 0)		endif	endif	end//*******************************************************************************// Background scan to get values for E4050 till it reaches a position// Last modified Sep 28 2010 by Jamie BoydFunction E4050_BkgScan()		NVAR axisBits = root:packages:E4050:AxisBIts 	variable xS=NaN, yS=NaN, zS=NaN, aS=NaN		if (axisBits & 1)		xS = 1		NVAR reqX = root:packages:E4050:reqX	endif	if (AxisBIts & 2)		yS = 1		NVAR reqY = root:packages:E4050:reqY	endif	if (AxisBIts & 4)		zS = 1		NVAR reqZ = root:packages:E4050:reqZ	endif	StageUpDate_E4050 (xS, yS, zS, aS)	if (AxisBIts & 1)		if ((xS + kE4050err > reqX) && (xS - kE4050err < reqX)) 			AxisBIts -= 1		endif	endif	if (AxisBIts & 2)		if ((yS + kE4050err > reqY) && (yS - kE4050err < reqY)) 			AxisBits -= 2		endif	endif	if (AxisBIts & 4)		if ((zS + kE4050err > reqZ) && (zS - kE4050err < reqZ)) 			AxisBits -= 4		endif	endif	// Are we still moving?	if (AxisBits > 0)		return 0 // so bkg task is continued	else // no longer busy. return 1 stop stop BGK task		BackGrounder_RemoveTask ("E4050_BkgScan()")		return 1	endifend//***********************************************************************************	// function to turn ON/Off bkg task that periodically updates axes values// Suggest you do not use, because simultaneous manual and computer usage of E4050 do not wok wellFunction StageSetAuto_E4050 (turnOn)	variable turnOn		if (turnOn)		BackGrounder_AddTask("E4050_BkgUpdate()", 15) // 4/second should be fast enough	else		BackGrounder_RemoveTask ("E4050_BkgUpdate()")	endifend//***********************************************************************************	// The backGround task to periodically check position (which I recommend you do not use)Function E4050_BkgUpdate()		NVAR isBusy = root:packages:E4050:isBusy	if (isBusy) 		return 0	else		variable xS=1, yS=1, zS=1, AxS=0		StageUpDate_E4050 (xS, yS, zS, AxS)		return 0	endifend//*******************************************************************************// Sets the current position to be Zero, i.e.distance from Zero =0.// Some stage encoders, like e4050, support a home position seprate from zero, but it is not supportd in this code// Lat Modified Sep 07 2010 by Jamie BoydFunction StageSetzero_E4050()		NVAR isBusy = root:packages:E4050:isBusy	if (isBusy)		return 0	endif	isBusy=1; doUpdate	WAVE/b/u OBPWave = root:packages:E4050:OBPWave	WAVE/B/U IBPWAve = root:packages:E4050:IBPWave	OBPWave [0] = char2num ("N")	OBPWave [1,8] = char2num ("0")	execute "VDTWriteBinaryWave/Q/O=(kE4050Sleep) root:packages:E4050:OBPwave"	// clear buffer by reading it into the wave	IBPWave = 0	execute "VDTReadBinaryWave/Q/O=(kE4050Sleep)/F=2  root:packages:E4050:IBPwave"	if (kE4050debug)		PrintE4050OutPut()	endif	// assume we succesfully zeroed the device	NVAR LastX = root:packages:E4050:xDistanceFromzero	NVAR LastY = root:packages:E4050:yDistanceFromzero	NVAR LastZ = root:packages:E4050:zDistanceFromzero	LastX = 0	LastY = 0	LastZ = 0	isBusy = 0	return 0end//*************************************************************************************************// function to lock joystick to stop manual movement of stage encoder// Last Modified Sep 07 2010 by Jamie BoydFunction StageSetManual_E4050 (doLock)	variable doLock //1 to lock manual movement of stage, 0 to unlock		NVAR isBusy = root:packages:E4050:isBusy	if (isBusy)		return 0	endif	isBusy=1; doUpdate	WAVE/b/u OBPWave = root:packages:E4050:OBPWave	WAVE/B/U IBPWAve = root:packages:E4050:IBPWave	OBPWave [0] = char2num ("D")	if (doLock)		OBPWave [1] = char2num ("1")	else		OBPWave [1] = char2num ("0")	endif	// zero rest of wave	OBPWave [2,8] = char2num ("0")	execute "VDTWriteBinaryWave/Q/O=(kE4050Sleep) root:packages:E4050:OBPwave"	// clear buffer by reading it into the wave	iBPWave = 0	execute "VDTReadBinaryWave/Q/O=(kE4050Sleep)/F=2  root:packages:E4050:IBPwave"	if (kE4050debug)		PrintE4050OutPut()	endif	isBusy = 0	return 0end//*************************************************************************************************// Sets PID values for the E4050 stage encoder, can set 1,2, or 3 PID values at once// Last Modified Sep 13 2010 by Jamie BoydFunction StageSetPID_E4050 (theAxis, [pS, iS, dS])	string theAxis	variable pS, iS, dS		NVAR isBusy = root:packages:E4050:isBusy	isBusy = 1;doUpdate	// make sure axis is capitalized	theAxis = UpperStr(theAxis)	if (cmpStr (theAxis, "Z") ==0)		doalert 0, "E4050 uses a sinple stepper motor to set the Z-axis, and does not support setting or getting PID values for Z."		isBusy = 0		return 0	endif	// reference output wave	WAVE/b/u OBPWave = root:packages:E4050:OBPwave	WAVE/b/u IBPWave = root:packages:E4050:IBPwave	// string to generate commands	string e4050inputStr	// set the axis in the output wave	OBPwave [0] = char2Num (theAxis)	// set "Setting PID" character	OBPwave [1] = char2Num ("C")	// zero rest of wave	OBPWave [3,8] = char2num ("0")	// P 	if (!(paramisdefault (pS)))		OBPwave [2] = char2Num ("P")		sprintf e4050inputStr, "%.4d", round (pS)		OBPWave [5,8] = char2num(e4050inputStr [p -5])		// write the output wave into the buffer		execute "VDTWriteBinaryWave/O=(kE4050Sleep) root:packages:E4050:OBPwave"		sleep /C=-1/S (kE4050Sleep)		// read  the buffer into the input wave just to clear buffer		IBPWave = 0		execute "VDTReadBinaryWave/Q/O=(kE4050Sleep)/F=2  root:packages:E4050:IBPwave"		if (kE4050debug)			PrintE4050OutPut()		endif	endif	// I 	if (!(paramisdefault (iS)))		OBPwave [2] = char2Num ("I")		sprintf e4050inputStr, "%.4d", round (iS)		OBPWave [5,8] = char2num(e4050inputStr [p -5])		// write the output wave into the buffer		execute "VDTWriteBinaryWave/Q/O=(kE4050Sleep) root:packages:E4050:OBPwave"		sleep /C=-1/S (kE4050Sleep)		// read  the buffer into the input wave just to clear buffer		IBPWave = 0		execute "VDTReadBinaryWave/Q/O=(kE4050Sleep)/F=2  root:packages:E4050:IBPwave"		if (kE4050debug)			PrintE4050OutPut()		endif	endif	// D	if (!(paramisdefault (dS)))		OBPwave [2] = char2Num ("D")		sprintf e4050inputStr, "%.4d", round (dS)		OBPWave [5,8] = char2num(e4050inputStr [p -5])		// write the output wave into the buffer		execute "VDTWriteBinaryWave/Q/O=(kE4050Sleep) root:packages:E4050:OBPwave"		sleep /C=-1/S (kE4050Sleep)		// read  the buffer into the input wave just to clear buffer		IBPWave = 0		execute "VDTReadBinaryWave/Q/O=(kE4050Sleep)/F=2  root:packages:E4050:IBPwave"		if (kE4050debug)			PrintE4050OutPut()		endif	endif	isBusy = 0end//*************************************************************************************************// Reads PID values from the E4050 stage encoder, for a single axes, for any or all PID// Last Modified Sep 29 2010 by Jamie BoydFunction StageFetchPID_E4050 (theAxis, pS, iS, dS)	string theAxis	variable &pS, &iS, &dS		NVAR isBusy = root:packages:E4050:isBusy	isBusy = 1;doUpdate	// make sure axis is capitalized	theAxis = UpperStr(theAxis)	if (cmpStr (theAxis, "Z") ==0)		doalert 0, "E4050 uses a simple stepper motor to set the Z-axis, and does not support setting or getting PID values for Z."		isBusy = 0		return 0	endif	// reference input and output waves	WAVE/b/u OBPWave = root:packages:E4050:OBPwave	WAVE/b/u IBPWave = root:packages:E4050:IBPwave	// string to parse input	string e4050inputStr	variable ii, readVal	// set the axis in the output wave	OBPwave [0] = char2Num (theAxis)	// set "Setting PID" character	OBPwave [1] = char2Num ("B")	// zero rest of wave	OBPWave [3,8] = char2num ("0")	// P	if (numtype (pS) ==0)		NVAR PIDp = $"root:packages:E4050:" + theAxis + "PIDp"		OBPwave [2] = char2Num ("P")		// write the output wave into the buffer		execute "VDTWriteBinaryWave/Q/O=(kE4050Sleep) root:packages:E4050:OBPwave"		sleep /C=-1/S (kE4050Sleep)		// read  the buffer into the input wave		IBPWave = 0		execute "VDTReadBinaryWave/Q/O=(kE4050Sleep)/F=2  root:packages:E4050:IBPwave"		if (kE4050debug)			PrintE4050OutPut()		endif		// Parse the wave		// look for first number		for (ii=10;ii < 50 && ((IBPWave [ii] < 47) || (IBPWave [ii] > 57)); ii+=1)		endfor		if (ii == 50)			print "E4050 failed to read the \"P\" PID value for the \"" + theAxis + "\" axis."			PIDp =Nan		else // read numeric characters (ASCII 48 to 57 into string			e4050inputStr = num2char (IBPWave [ii]) 			for (ii+=1;ii < 50 && ((IBPWave [ii] > 47) && (IBPWave [ii] < 58)); ii += 1)				e4050inputStr += num2char (IBPWave [ii])			endfor			readVal = str2num (e4050inputStr)			if (numtype (readVal) == 0)				pS = readval				PIDp = pS			else				pS =Nan				print"E4050 failed to read the \"P\" PID value for the \"" + theAxis + "\" axis. What was read was:", e4050inputStr			endif		endif	else		pS = Nan	endif	// I	if (numtype (iS) == 0)		NVAR PIDi = $"root:packages:E4050:" + theAxis + "PIDi"		OBPwave [2] = char2Num ("I")		// write the output wave into the buffer		execute "VDTWriteBinaryWave/Q/O=(kE4050Sleep) root:packages:E4050:OBPwave"		sleep /C=-1/S (kE4050Sleep)		// read  the buffer into the input wave		IBPWave = 0		execute "VDTReadBinaryWave/Q/O=(kE4050Sleep)/F=2  root:packages:E4050:IBPwave"		if (kE4050debug)			PrintE4050OutPut()		endif		// Parse the wave		// look for first number		for (ii=10;ii < 50 && ((IBPWave [ii] < 47) || (IBPWave [ii] > 57)); ii+=1)		endfor		if (ii == 50)			print "E4050 failed to read the \"I\" PID value for the \"" + theAxis + "\" axis."			PIDi =Nan		else // read numeric characters (ASCII 48 to 57 into string			e4050inputStr = num2char (IBPWave [ii]) 			for (ii+=1;ii < 50 && ((IBPWave [ii] > 47) && (IBPWave [ii] < 58)); ii += 1)				e4050inputStr += num2char (IBPWave [ii])			endfor			readVal = str2num (e4050inputStr)			if (numtype (readVal) == 0)				iS = readval				PIDi = iS			else				iS =Nan				print"E4050 failed to read the \"I\" PID value for the \"" + theAxis + "\" axis. What was read was:", e4050inputStr			endif		endif	else		iS = Nan	endif	// D	if (numtype (dS) ==0)		NVAR PIDd = $"root:packages:E4050:" + theAxis + "PIDd"		OBPwave [2] = char2Num ("D")		// write the output wave into the buffer		execute "VDTWriteBinaryWave/Q/O=(kE4050Sleep) root:packages:E4050:OBPwave"		sleep /C=-1/S (kE4050Sleep)		// read  the buffer into the input wave		IBPWave = 0		execute "VDTReadBinaryWave/Q/O=(kE4050Sleep)/F=2  root:packages:E4050:IBPwave"		if (kE4050debug)			PrintE4050OutPut()		endif		// Parse the wave		// look for first number		for (ii=10;ii < 50 && ((IBPWave [ii] < 47) || (IBPWave [ii] > 57)); ii+=1)		endfor		if (ii == 50)			print "E4050 failed to read the \"D\" PID value for the \"" + theAxis + "\" axis."			PIDd =Nan		else // read numeric characters (ASCII 48 to 57 into string			e4050inputStr = num2char (IBPWave [ii]) 			for (ii+=1;ii < 50 && ((IBPWave [ii] > 47) && (IBPWave [ii] < 58)); ii += 1)				e4050inputStr += num2char (IBPWave [ii])			endfor			readVal = str2num (e4050inputStr)			if (numtype (readVal) == 0)				dS = readval				PIDd = dS			else				dS =Nan				print"E4050 failed to read the \"D\" PID value for the \"" + theAxis + "\" axis. What was read was:", e4050inputStr			endif		endif	else		dS = Nan	endif	isBusy = 0end//*************************************************************************************************// Utility function to print output of E4050, as read into the IBP wave, to the command line// Last Modified Sep 13 by Jamie Boydfunction PrintE4050OutPut ()		WAVE/b/u outPut = root:packages:E4050:IBPwave	variable ii, nChars = numpnts (outPut)	for (ii =0; ii < nChars; ii +=1)		printf num2char (outPut [ii])	endfor	print "\r"end