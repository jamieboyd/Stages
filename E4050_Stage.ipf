#pragma rtGlobals=1		// Use modern global access method.#include "Stages"#pragma version= 2.0		// modification date Nov 25 2010 by Jamie Boyd#pragma IgorVersion=7//E4050 requires the VDT2 XOP//Procedures for controlling the E4050 serial port-driven X-Y stage/focus motor controller // programmed by Pawel Kowalski (pk@sfu.ca) at the SFU machine shop.//***********************************************CONSTANTS********************************************// Because stage encoders can be mounted in various configurations, going more negative along the X-axis, e.g., may not always// correspond to going left as viewed through the microscope. And the Z-encoder may be mounted on left or right side, which could change polarity.// Therefore, we need some constants for the various directions for use with left/right, forward/back, and up/down buttons on the control panel :STATIC CONSTANT kE4050xPol = -1STATIC CONSTANT kE4050yPol = 1STATIC CONSTANT kE4050zPol = -1// variables for maximum and minimum distance from 0 for XY and Z, changes these as appropriateSTATIC CONSTANT kE4050xyMIN = -50e-03STATIC CONSTANT kE4050xyMAX = 50e-03STATIC CONSTANT kE4050zMIN = -5e-03STATIC CONSTANT kE4050zMAX = 5e-03// acceptable error for  positioning when testing to see if a position has been obtained and we can assume movement is finishedSTATIC CONSTANT kE4050err = 5e-7  // 0.5 microns // Time in seconds to wait between a read and a write, and to wait for a read to finish. // If you are getting errors while reading, maybe make this value a little bigger // Not static because we need to use it in execute statementsCONSTANT  kE4050Sleep = 0.02 // speed in m/sec needed for waiting after a move before reading, different for XY and Z axes // The stage average speed is not constant between long and short movements, of course, but this will hvae to do for now.  // You can tweak these values, listening to the XY stage or monitoring the z axis update while watching the activity indicator // The activity indicator should go black just after a move completes CONSTANT kE4050XYSpeed = 0.5e-03CONSTANT kE4050ZSpeed = 35e-06// Step sizes for XY and Z movement (resolution in meters per microstep; needed to convert values from meters to microsteps)CONSTANT  kE4050XYstepSize = 1e-07CONSTANT  kE4050ZstepSize = 2.5e-07//  Provide autoUpdate check not useful with E4050, as manual and auto commands collide. I would suggest leaving this as 0STATIC CONSTANT kE4050doAuto = 0// PID default values, as originally set by Pavel.// NOTE: z-axis is set by a simple stepper motor, and, as such, has no PID capacityCONSTANT kE4050xPIDpDef = 2000CONSTANT kE4050xPIDiDef = 5CONSTANT kE4050xPIDdDef = 2CONSTANT kE4050yPIDpDef = 2000CONSTANT kE4050yPIDiDef = 5CONSTANT kE4050yPIDdDef = 2//******************************Info for programming E4050 Commands********************************************//First character: 1 of X,Y,Z  to select an axis, N to set new 0 for X,Y,Z, or D to disable manual controls//Second character when using D to disable: 0 to disable manual conrols, 1 to enable them//Second character when using X,Y,Z to choose an axis: A to set absolute position from 0, R to set relative position  from current position,//P to get current position, H to get the Zero value, S to set the Zero value to the current position, G to go Zero, C to set PID coefficients, B to read PID coefficients//When giving a value to move the axis,  the format is plus/minus then a 6 digit number, which is in microsteps//When giving a value to set PID coeficients, the +/- sign is replaced by P, I, or D for setting each value (All PID values are positive)//All commands end with a carriage return (CR, ascii value 13)//For commands where a value is not padded (N, D, and XP, XH, etc), commands are padded with 0's plus CR  so all commands are 10 characters long//Example commands://D00000000CR - Enable the manual interface//D10000000CR - Disable the manual interface//N00000000CR - Set a new 0 position for X,Y, and Z////XA+000200CR  - put the X axis to 20 microns away from 0//XR-000200CR  - put the X axis 20 microns posterior to the current position//XG0000000CR - put the X axis to the defined Zero position (same as hitting the Go to Zero button on the box)////XS0000000CR  - set the Zero position for the X axis to the current X position (same as hitting the set Zero button on the box)////XP0000000CR - Send back to the computer the current position of the X axis in the same 6 character format plus CR//XH0000000CR - Send back to the computer the Zero position of the X axis in the same 6 character format plus CR////XCP000200CR - Sets Kp for X axis movement to 2000//XCI000200CR - Sets Ki for X axis movement to 200//XCD000200CR - Sets KD for X axis movement to 200////XBP000000CR - send back to the computer the current Kp value for X axis movement//XBI000000CR - send back to the computer the current Ki value for X axis movement//XBD000000CR - send back to the computer the current Kd value for X axis movementSTATIC CONSTANT kE4050debug = 0 // prints info to history for debugging//*******************************************************************************// make global variables.// Last modified Sep 07 2010 by Jamie BoydFunction StageInitGlobals_E4050 ()	if (!(datafolderExists ("root:packages:")))		newDataFolder root:packages:	endif 	if (!(datafolderExists ("root:packages:E4050:")))		newdatafolder root:packages:E4050	endif	// string for port name - will be set by user from popmenu which calls StageSetUpPort_E4050	string/G root:packages:E4050:thePort	// Read XY- and  Z-capability from static contstant at top of file	variable/G root:packages:E4050:hasXY = 1	variable/G root:packages:E4050:hasZ = 1	// No axial positioning	variable/G  root:packages:E4050:hasAx = 0	// Is motorized and manual lock	variable/G root:packages:E4050:hasMotor = 1	variable/G root:packages:E4050:hasLock = 1	variable/G root:packages:E4050:isLocked =0	// Has ability to change PID settings	variable/G root:packages:E4050:hasPID=1	// Serial device, not USB	variable/G root:packages:E4050:isUSB = 0	// Make a byte wave to create VDT outputs and inputs	// 48 is ASCII 0, and 13 is ASCII return	make/o/b root:packages:E4050:OBPwave = {48,48,48,48,48,48,48,48,48,13} 	make/o/b/n= 30 root:packages:E4050:IBPwave 	// variables for distances from 0	variable/G  root:packages:E4050:xDistanceFromzero	variable/G  root:packages:E4050:yDistanceFromzero	variable/G  root:packages:E4050:zDistanceFromzero	// step sizes for relative moves	variable/G  root:packages:E4050:xStepSize =(10 * kE4050XYstepSize)	variable/G  root:packages:E4050:yStepSize= (10 * kE4050XYstepSize)	variable/G  root:packages:E4050:zStepSize= (4 * kE4050ZstepSize)	// resolution (minimun step size)	variable/G  root:packages:E4050:xyRes = kE4050XYstepSize	variable/G  root:packages:E4050:zRes = kE4050ZstepSize	// minimum and maximum distances from 0	variable/G  root:packages:E4050:xyMIN = kE4050XYMIN	variable/G  root:packages:E4050:xyMAX = kE4050XYMAX	variable/G  root:packages:E4050:zMIN = kE4050ZMIN	variable/G  root:packages:E4050:zMAX = kE4050ZMAX	// polarity of the axes movement	variable/G  root:packages:E4050:xPol = kE4050xPol	variable/G  root:packages:E4050:yPol = kE4050yPol	variable/G  root:packages:E4050:zPol = kE4050zPol	// Autoupdate availability - not useful with E4050, as manual and auto commands collide, I recommend not using	variable/G root:packages:E4050:hasAuto =kE4050doAuto	variable/G root:packages:E4050:autoON	// variables for PID - we make z even though we can't set PID for Z, just so no errors are thrown when PID panel is created	variable/G  root:Packages:E4050:xPIDp	variable/G root:Packages:E4050:xPIDi	variable/G root:Packages:E4050:xPIDd	variable/G  root:Packages:E4050:yPIDp	variable/G root:Packages:E4050:yPIDi	variable/G root:Packages:E4050:yPIDd	variable/G  root:Packages:E4050:zPIDp	variable/G root:Packages:E4050:zPIDi	variable/G root:Packages:E4050:zPIDd	// Default PID values, from constants	variable/G  root:Packages:E4050:xPIDpDef = kE4050xPIDpDef	variable/G root:Packages:E4050:xPIDiDef = kE4050xPIDiDef	variable/G root:Packages:E4050:xPIDdDef = kE4050xPIDdDef	variable/G  root:Packages:E4050:yPIDpDef= kE4050yPIDpDef	variable/G root:Packages:E4050:yPIDiDef =  kE4050yPIDiDef	variable/G root:Packages:E4050:yPIDdDef=kE4050yPIDdDefend	//*********************************************************************************************// Opens the serial port for use with E4050// Last modified 2017/12/16 Jamie BoydFunction StageSetUpPort_E4050 (thePortName)	string thePortName	// Open the port with the correct settings	VDT2/P = $PossiblyQuoteName (thePortName) baud=9600, stopbits=1, databits=8, parity=0, in=0, out=0, buffer=4096	VDTOpenPort2 $PossiblyQuoteName (thePortName)	VDTOperationsPort2 $PossiblyQuoteName (thePortName)	//Clear buffer 	StageResetIO_E4050 ()end//*********************************************************************************************// Reset I/O function for E4050, clears any pending commands// Last Modified Sep 07 2010 by Jamie BoydFunction StageResetIO_E4050 ()		NVAR isBusy = root:packages:E4050:isBusy	isBusy = 1;doUpdate	SVAR thePortName = root:packages:E4050:thePort	vdt2/P =$possiblyquotename (thePortName) killio	isBusy = 0	return 0end//*******************************************************************************//Frees the Serial Portfunction StageClose_E4050(thePortName)	string thePortName		//BackGrounder_RemoveTask ("E4050_BkgScan()")	//BackGrounder_RemoveTask ("E4050_BkgUpdate()")	//execute "VDTGetPortList"	VDTGetPortList2	if (findListItem (thePortName, S_VDT, ";") > -1)		VDTClosePort2 $PossiblyQuoteName (thePortName)	endif	NVAR isBusy = root:packages:E4050:isBusy	isBusy = 0end//*******************************************************************************// Gets the co-ordinates from the stage and focus, and puts them in the cooresponding global variables// Last Modified Sep 07 2010 by Jamie BoydFunction StageUpDate_E4050 (xS, yS, zS, aS)	variable &xS, &yS,&zS, &aS		// Globals	NVAR isBusy= root:packages:E4050:isBusy	if (isBusy)		return 1	endif	isBusy = 1;doupdate	NVAR lastX= root:packages:E4050:xDistanceFromzero	NVAR lastY = root:packages:E4050:yDistanceFromzero	NVAR lastZ =  root:packages:E4050:zDistanceFromzero	SVAR thePort = root:packages:E4050:thePort	WAVE/B/U OBP=  root:packages:E4050:OBPwave	WAVE/B/U IBP = root:packages:E4050:IBPwave 	variable iChar, readVal , nCHar	string e4050output = ""	// Zero middle part of wave	OBP [2,8] = 48	// Set 1st character to P for get position	OBP [1]= char2num ("P")	// iterate through axes	make/free/b/n=3 axesList	axesList =88 + p 	variable iAxis, nAxes = 3	SVAR thePortName = root:packages:E4050:thePort	for (iAxis = 0; iAxis < nAxes;iAxis +=1)		if ((iAxis ==0) && (numtype (xS) !=0))			continue		endif		if ((iAxis ==1) && (numtype (yS) !=0))			continue		endif		if ((iAxis ==2) && (numtype (zS) !=0))			continue		endif		// set 0th character to axis		OBP [0]= axesList[iAxis]		// write the output wave into the buffer				VDTWriteBinaryWave2/P =$possiblyquotename (thePortName)/O=(kE4050Sleep)/Q OBP		sleep /C=-1/S kE4050Sleep		VDTGetStatus2/P =$possiblyquotename (thePortName) 0,0,0		nChar = V_VDT		if (nCHar != 30)			printf "nchars read was %d and was expecting 30. Power cycle time.\r", nChar			return 0		endif		// read  the buffer into the input wave		IBP=0		VDTReadBinaryWave2/P =$possiblyquotename (thePortName) /O=(kE4050Sleep) /Q IBP		// parse data		if ((IBP [9] != axesList[iAxis]) && (IBP [9] != char2num ("P")))			continue		endif		e4050output =""		for (iChar =11 ;iChar < 18; iChar+=1)			e4050output += num2char (IBP [iChar])		endfor		NVAR globalVal = $"root:packages:E4050:" + num2char (axesList[iAxis]) +"DistanceFromzero"		if (axesList[iAxis] < 90)			globalVal =  str2num (e4050output) * kE4050XYstepSize		else			globalVal =  str2num (e4050output) * kE4050ZstepSize		endif		if (iAxis ==0)			xS = globalVal		endif		if (iAxis ==1)			yS = globalVal		endif		if (iAxis ==2)			zS = globalVal		endif	endfor	isBusy = 0end//***********************************************************************************	// Stage move function for E4050 stage encoders// Last Modified Sep 07 2010 by Jamie BoydFunction StageMove_E4050 (moveType, returnWhen, xS, yS, zS, aS)	variable moveType  //  0 if requesting movement to an absolute position non-zero if requesting positive movement relative to current location,	// moveType will be -1 for negative movements, +1 for positive movements.	variable returnWhen //0 to return immediately,1 to wait until movement is finished to return, 2 to set a background task that monitors when we get there	variable  &xS, &yS, &zS, &aS // variables that will hold the retreived absolute positions		// Global for is Busy	NVAR isBusy= root:packages:E4050:isBusy	if (isBusy)		return 1	endif	isBusy = 1;doupdate	SVAR thePortName =  root:packages:E4050:thePort	NVAR LastX = root:packages:E4050:xDistanceFromzero	NVAR LastY = root:packages:E4050:yDistanceFromzero	NVAR LastZ = root:packages:E4050:zDistanceFromzero	WAVE/b/u OBPWave = root:packages:E4050:OBPwave	WAVE/b/u IBPWave = root:packages:E4050:IBPwave	string e4050inputStr	variable ii, mv // mv is calculated distance the stage will be moving	variable/G root:packages:e4050:axisBits	NVAR axisBits = root:packages:e4050:axisBits	axisBits = 0	// request the movements	if (moveType == kStagesIsAbs )		OBPwave [1] = char2Num ("A")	else		OBPwave [1] = char2Num ("R")	endif	// X 	if (numType (xS) == 0)		axisBits += 1		// Zero middle part of wave		OBPWave [3,8] = 48		// Select X axis		OBPWave [0] = char2num ("X")		// If is relative, account for polarity		if ((moveType == kStagesIsRelPos) || (moveType == kStagesIsRelNeg))			mv = abs (xS)			NVAR polarityMult = root:packages:E4050:xPol			xS *= (polarityMult * moveType)			if (returnWhen == kStagesReturnNow)				LastX += xS			endif		else // moving to an absolute location			mv = abs (lastx - xS)			if (returnWhen == kStagesReturnNow)				LastX = xS			endif		endif		if (xS> 0)			sprintf e4050inputStr, "+%.6d", round ((xS/kE4050XYstepSize))		else			sprintf e4050inputStr, "-%.6d", round (-1*((xS/kE4050XYstepSize)))		endif		OBPWave [2,8] = char2num (e4050inputStr[p-2])		// write the output wave into the buffer		IBPWave =0		VDTWriteBinaryWave2/P =$possiblyquotename (thePortName)/O=(kE4050Sleep) /Q OBPWave		// sleep depending on distance traveled		sleep /C=-1/S (kE4050Sleep + mv/kE4050XYSpeed)		// read  the buffer into the input wave just to clear buffer		VDTReadBinaryWave2/P =$possiblyquotename (thePortName) /O=(kE4050Sleep) /Q IBPWave		if (kE4050debug)			PrintE4050OutPut()		endif	endif	// Y	if (numtype (yS) == 0)		axisBits += 2		// Zero middle part of wave		OBPWave [3,8] = 48		// Select Y axis		OBPWave [0] = char2num ("Y")		// If is relative, account for polarity		if ((moveType == kStagesIsRelPos) || (moveType == kStagesIsRelNeg))			mv = abs (yS)			NVAR polarityMult = root:packages:E4050:yPol			yS *= (polarityMult * moveType)			if (returnWhen ==kStagesReturnNow)				LastY += yS			endif		else			mv = abs (lasty - yS)			if (returnWhen ==kStagesReturnNow)				LastY = yS			endif		endif		if (yS > 0)			sprintf e4050inputStr, "+%.6d", round (abs((yS/kE4050XYstepSize)))		else			sprintf e4050inputStr, "-%.6d", round (abs((yS/kE4050XYstepSize)))		endif		OBPWave [2,8] = char2num (e4050inputStr[p-2])		// write the output wave into the buffer		VDTWriteBinaryWave2/P =$possiblyquotename (thePortName)/O=(kE4050Sleep) /Q OBPWave		// sleep depending on distance traveled		sleep /C=-1/S (kE4050Sleep + mv/kE4050XYSpeed)		// read  the buffer into the input wave just to clear buffer		IBPWave = 0		VDTReadBinaryWave2/P =$possiblyquotename (thePortName) /O=(kE4050Sleep) /Q IBPWave		if (kE4050debug)			PrintE4050OutPut()		endif	endif	// Z	if (numtype (zS) == 0)		axisBits += 4		// Zero middle part of wave		OBPWave [3,8] = 48		// Select Z axis		OBPWave [0] = char2num ("Z")		// If is relative, account for polarity		if ((moveType == kStagesIsRelPos) || (moveType == kStagesIsRelNeg))			mv = abs (zS)			NVAR polarityMult = root:packages:E4050:zPol			zS *= (polarityMult * moveType)			if (returnWhen ==kStagesReturnNow)				LastZ += zS			endif		else			mv = abs (lastz - zS)			if (returnWhen ==kStagesReturnNow)				lastZ = zS			endif		endif		if (zS> 0)			sprintf e4050inputStr, "+%.6d", round (abs((zS/kE4050ZstepSize)))		else			sprintf e4050inputStr, "-%.6d", round (abs((zS/kE4050ZstepSize)))		endif		OBPWave [2,8] = char2num (e4050inputStr[p-2])		// write the output wave into the buffer		VDTWriteBinaryWave2/P =$possiblyquotename (thePortName)/O=(kE4050Sleep) /Q OBPWave		// sleep depending on distance traveled		sleep /C=-1/S (kE4050Sleep + mv/kE4050ZSpeed)		// read  the buffer into the input wave just to clear buffer		IBPWave =0		VDTReadBinaryWave2/P =$possiblyquotename (thePortName) /O=(kE4050Sleep) /Q IBPWave		if (kE4050debug)			PrintE4050OutPut()		endif	endif	isBusy = 0	// either set a background task or a loop to get stage coordinates	if ((returnWhen == kStagesReturnLater) || (returnWhen == kStagesReturnBkg))		sleep /C=-1/S (kE4050Sleep)		if (AxisBIts & 1)			variable/G root:packages:E4050:reqX			NVAR reqX = root:packages:E4050:reqX			if (moveType ==kStagesIsAbs)				reqX = xS			else				reqX = lastX + xS			endif			xS =1		else			xS = NaN		endif		if (AxisBIts & 2)			variable/G root:packages:E4050:reqY			NVAR reqY = root:packages:E4050:reqY			if (moveType ==kStagesIsAbs)				reqY = yS			else				reqY = lastY + yS			endif			yS =1		else			yS = Nan		endif		if (AxisBIts & 4)			variable/G root:packages:E4050:reqZ			NVAR reqZ = root:packages:E4050:reqZ			if (moveType ==kStagesIsAbs)				reqZ =zS			else				reqZ =  lastZ + zS			endif			zS=1		else			zS =NaN		endif		// set up background task or loop		if (returnWhen == kStagesReturnBkg)			CtrlNamedBackground E4050_BKG, period=30, proc=E4050_BkgScan			CtrlNamedBackground E4050_BKG, start		elseif (returnWhen ==kStagesReturnLater)			do				StageUpDate_E4050 (xS, yS, zS, aS)				if (AxisBIts & 1)					if ((xS + kE4050err > reqX) && (xS - kE4050err < reqX)) 						AxisBIts -= 1						xS =NaN					else						xS=1					endif				endif				if (AxisBIts & 2)					if ((yS + kE4050err > reqY) && (yS - kE4050err < reqY)) 						AxisBits -= 2						yS=NaN					else						yS=1					endif				endif				if (AxisBIts & 4)					if ((zS + kE4050err > reqZ) && (zS - kE4050err < reqZ)) 						AxisBits -= 4						zS=NaN					else						zS=1					endif				endif			while (AxisBIts > 0)		endif	endif	end//*******************************************************************************// Background scan to get values for E4050 till it reaches a position// Last modified 2035/07/21 by Jamie BoydFunction E4050_BkgScan(s)		// This is the function that will be called periodically	STRUCT WMBackgroundStruct &s	NVAR axisBits = root:packages:E4050:AxisBIts 	variable xS=NaN, yS=NaN, zS=NaN, aS=NaN		if (axisBits & 1)		xS = 1		NVAR reqX = root:packages:E4050:reqX	endif	if (AxisBIts & 2)		yS = 1		NVAR reqY = root:packages:E4050:reqY	endif	if (AxisBIts & 4)		zS = 1		NVAR reqZ = root:packages:E4050:reqZ	endif	StageUpDate_E4050 (xS, yS, zS, aS)	if (AxisBIts & 1)		if ((xS + kE4050err > reqX) && (xS - kE4050err < reqX)) 			AxisBIts -= 1		endif	endif	if (AxisBIts & 2)		if ((yS + kE4050err > reqY) && (yS - kE4050err < reqY)) 			AxisBits -= 2		endif	endif	if (AxisBIts & 4)		if ((zS + kE4050err > reqZ) && (zS - kE4050err < reqZ)) 			AxisBits -= 4		endif	endif	// Are we still moving?	if (AxisBits > 0)		return 0 // so bkg task is continued	else // no longer busy. return 1 stop  BGK task		return 1	endifend//***********************************************************************************	// function to turn ON/Off bkg task that periodically updates axes values// Suggest you do not use, because simultaneous manual and computer usage of E4050 do not wok wellFunction StageSetAuto_E4050 (turnOn)	variable turnOn		if (turnOn)		CtrlNamedBackground E4050_AUTO, period=20, proc=E4050_BkgUpdate		CtrlNamedBackground E4050_AUTO, start	else		CtrlNamedBackground E4050_AUTO, stop	endifend//***********************************************************************************	// The backGround task to periodically check position (which I recommend you do not use)Function E4050_BkgUpdate(s)	STRUCT WMBackgroundStruct &s		NVAR isBusy = root:packages:E4050:isBusy	if (isBusy) 		return 0	else		variable xS=1, yS=1, zS=1, AxS=0		StageUpDate_E4050 (xS, yS, zS, AxS)		return 0	endifend//*******************************************************************************// Sets the current position to be Zero, i.e.distance from Zero =0.// Some stage encoders, like e4050, support a home position seprate from zero, but it is not supportd in this code// Lat Modified Sep 07 2010 by Jamie BoydFunction StageSetzero_E4050()		NVAR isBusy = root:packages:E4050:isBusy	SVAR thePortName = root:packages:E4050:thePort	if (isBusy)		return 0	endif	isBusy=1; doUpdate	WAVE/b/u OBPWave = root:packages:E4050:OBPWave	WAVE/B/U IBPWAve = root:packages:E4050:IBPWave	OBPWave [0] = char2num ("N")	OBPWave [1,8] = char2num ("0")	VDTWriteBinaryWave2/P =$possiblyquotename (thePortName)/O=(kE4050Sleep) /Q OBPWave	// clear buffer by reading it into the wave	IBPWave = 0	VDTReadBinaryWave2/P =$possiblyquotename (thePortName) /O=(kE4050Sleep) /Q IBPWave	if (kE4050debug)		PrintE4050OutPut()	endif	// assume we succesfully zeroed the device	NVAR LastX = root:packages:E4050:xDistanceFromzero	NVAR LastY = root:packages:E4050:yDistanceFromzero	NVAR LastZ = root:packages:E4050:zDistanceFromzero	LastX = 0	LastY = 0	LastZ = 0	isBusy = 0	return 0end//*************************************************************************************************// function to lock joystick to stop manual movement of stage encoder// Last Modified Sep 07 2010 by Jamie BoydFunction StageSetManual_E4050 (doLock)	variable doLock //1 to lock manual movement of stage, 0 to unlock		NVAR isBusy = root:packages:E4050:isBusy	SVAR thePortName = root:packages:E4050:thePort	if (isBusy)		return 0	endif	isBusy=1; doUpdate	WAVE/b/u OBPWave = root:packages:E4050:OBPWave	WAVE/B/U IBPWAve = root:packages:E4050:IBPWave	OBPWave [0] = char2num ("D")	if (doLock)		OBPWave [1] = char2num ("1")	else		OBPWave [1] = char2num ("0")	endif	// zero rest of wave	OBPWave [2,8] = char2num ("0")	VDTWriteBinaryWave2/P =$possiblyquotename (thePortName)/O=(kE4050Sleep) /Q OBPWave	// clear buffer by reading it into the wave	iBPWave = 0	VDTReadBinaryWave2/P =$possiblyquotename (thePortName) /O=(kE4050Sleep) /Q IBPwave	if (kE4050debug)		PrintE4050OutPut()	endif	isBusy = 0	return 0end//*************************************************************************************************// Sets PID values for the E4050 stage encoder, can set 1,2, or 3 PID values at once// Last Modified Sep 13 2010 by Jamie BoydFunction StageSetPID_E4050 (theAxis, [pS, iS, dS])	string theAxis	variable pS, iS, dS		NVAR isBusy = root:packages:E4050:isBusy	SVAR thePortName = root:packages:E4050:thePort	isBusy = 1;doUpdate	// make sure axis is capitalized	theAxis = UpperStr(theAxis)	if (cmpStr (theAxis, "Z") ==0)		doalert 0, "E4050 uses a simple stepper motor to set the Z-axis, and does not support setting or getting PID values for Z."		isBusy = 0		return 0	endif	// reference output wave	WAVE/b/u OBPWave = root:packages:E4050:OBPwave	WAVE/b/u IBPWave = root:packages:E4050:IBPwave	// string to generate commands	string e4050inputStr	// set the axis in the output wave	OBPwave [0] = char2Num (theAxis)	// set "Setting PID" character	OBPwave [1] = char2Num ("C")	// zero rest of wave	OBPWave [3,8] = char2num ("0")	// P 	if (!(paramisdefault (pS)))		OBPwave [2] = char2Num ("P")		sprintf e4050inputStr, "%.4d", round (pS)		OBPWave [5,8] = char2num(e4050inputStr [p -5])		// write the output wave into the buffer		VDTWriteBinaryWave2/P =$possiblyquotename (thePortName) /O=(kE4050Sleep) /Q OBP		sleep /C=-1/S (kE4050Sleep)		// read  the buffer into the input wave just to clear buffer		IBPWave = 0		VDTReadBinaryWave2/P =$possiblyquotename (thePortName)  /O=(kE4050Sleep) /Q IBP		if (kE4050debug)			PrintE4050OutPut()		endif	endif	// I 	if (!(paramisdefault (iS)))		OBPwave [2] = char2Num ("I")		sprintf e4050inputStr, "%.4d", round (iS)		OBPWave [5,8] = char2num(e4050inputStr [p -5])		// write the output wave into the buffer		VDTWriteBinaryWave2/P =$possiblyquotename (thePortName) /O=(kE4050Sleep) /Q OBP		sleep /C=-1/S (kE4050Sleep)		// read  the buffer into the input wave just to clear buffer		IBPWave = 0		VDTReadBinaryWave2/P =$possiblyquotename (thePortName)  /O=(kE4050Sleep) /Q IBP		if (kE4050debug)			PrintE4050OutPut()		endif	endif	// D	if (!(paramisdefault (dS)))		OBPwave [2] = char2Num ("D")		sprintf e4050inputStr, "%.4d", round (dS)		OBPWave [5,8] = char2num(e4050inputStr [p -5])		// write the output wave into the buffer		VDTWriteBinaryWave2/P =$possiblyquotename (thePortName) /O=(kE4050Sleep) /Q OBP		sleep /C=-1/S (kE4050Sleep)		// read  the buffer into the input wave just to clear buffer		IBPWave = 0		VDTReadBinaryWave2/P =$possiblyquotename(thePortName)  /O=(kE4050Sleep) /Q IBP		if (kE4050debug)			PrintE4050OutPut()		endif	endif	isBusy = 0end//*************************************************************************************************// Reads PID values from the E4050 stage encoder, for a single axes, for any or all PID// Last Modified Sep 29 2010 by Jamie BoydFunction StageFetchPID_E4050 (theAxis, pS, iS, dS)	string theAxis	variable &pS, &iS, &dS		NVAR isBusy = root:packages:E4050:isBusy	SVAR thePortName = root:packages:E4050:thePort	isBusy = 1;doUpdate	// make sure axis is capitalized	theAxis = UpperStr(theAxis)	if (cmpStr (theAxis, "Z") ==0)		doalert 0, "E4050 uses a simple stepper motor to set the Z-axis, and does not support setting or getting PID values for Z."		isBusy = 0		return 0	endif	// reference input and output waves	WAVE/b/u OBPWave = root:packages:E4050:OBPwave	WAVE/b/u IBPWave = root:packages:E4050:IBPwave	// string to parse input	string e4050inputStr	variable ii, readVal	// set the axis in the output wave	OBPwave [0] = char2Num (theAxis)	// set "Setting PID" character	OBPwave [1] = char2Num ("B")	// zero rest of wave	OBPWave [3,8] = char2num ("0")	// P	if (numtype (pS) ==0)		NVAR PIDp = $"root:packages:E4050:" + theAxis + "PIDp"		OBPwave [2] = char2Num ("P")		// write the output wave into the buffer		VDTWriteBinaryWave2/P =$possiblyquotename(thePortName)/O=(kE4050Sleep) /Q OBPWave		//execute "VDTWriteBinaryWave/Q/O=(kE4050Sleep) root:packages:E4050:OBPwave"		sleep /C=-1/S (kE4050Sleep)		// read  the buffer into the input wave		IBPWave = 0		VDTReadBinaryWave2/P =$possiblyquotename(thePortName) /O=(kE4050Sleep) /Q IBPWave		if (kE4050debug)			PrintE4050OutPut()		endif		// Parse the wave		// look for first number		for (ii=10;ii < 50 && ((IBPWave [ii] < 47) || (IBPWave [ii] > 57)); ii+=1)		endfor		if (ii == 50)			print "E4050 failed to read the \"P\" PID value for the \"" + theAxis + "\" axis."			PIDp =Nan		else // read numeric characters (ASCII 48 to 57 into string			e4050inputStr = num2char (IBPWave [ii]) 			for (ii+=1;ii < 50 && ((IBPWave [ii] > 47) && (IBPWave [ii] < 58)); ii += 1)				e4050inputStr += num2char (IBPWave [ii])			endfor			readVal = str2num (e4050inputStr)			if (numtype (readVal) == 0)				pS = readval				PIDp = pS			else				pS =Nan				print"E4050 failed to read the \"P\" PID value for the \"" + theAxis + "\" axis. What was read was:", e4050inputStr			endif		endif	else		pS = Nan	endif	// I	if (numtype (iS) == 0)		NVAR PIDi = $"root:packages:E4050:" + theAxis + "PIDi"		OBPwave [2] = char2Num ("I")		// write the output wave into the buffer		VDTWriteBinaryWave2/O=(kE4050Sleep) /Q OBPwave		//execute "VDTWriteBinaryWave/Q/O=(kE4050Sleep) root:packages:E4050:OBPwave"		sleep /C=-1/S (kE4050Sleep)		// read  the buffer into the input wave		IBPWave = 0		VDTReadBinaryWave2/P =$possiblyquotename(thePortName) /O=(kE4050Sleep) /Q IBP		if (kE4050debug)			PrintE4050OutPut()		endif		// Parse the wave		// look for first number		for (ii=10;ii < 50 && ((IBPWave [ii] < 47) || (IBPWave [ii] > 57)); ii+=1)		endfor		if (ii == 50)			print "E4050 failed to read the \"I\" PID value for the \"" + theAxis + "\" axis."			PIDi =Nan		else // read numeric characters (ASCII 48 to 57 into string			e4050inputStr = num2char (IBPWave [ii]) 			for (ii+=1;ii < 50 && ((IBPWave [ii] > 47) && (IBPWave [ii] < 58)); ii += 1)				e4050inputStr += num2char (IBPWave [ii])			endfor			readVal = str2num (e4050inputStr)			if (numtype (readVal) == 0)				iS = readval				PIDi = iS			else				iS =Nan				print"E4050 failed to read the \"I\" PID value for the \"" + theAxis + "\" axis. What was read was:", e4050inputStr			endif		endif	else		iS = Nan	endif	// D	if (numtype (dS) ==0)		NVAR PIDd = $"root:packages:E4050:" + theAxis + "PIDd"		OBPwave [2] = char2Num ("D")		// write the output wave into the buffer		VDTWriteBinaryWave2/P =$possiblyquotename(thePortName)/Q/O=(kE4050Sleep) OPB		sleep /C=-1/S (kE4050Sleep)		// read  the buffer into the input wave		IBPWave = 0		//execute "VDTReadBinaryWave/Q/O=(kE4050Sleep)/F=2  root:packages:E4050:IBPwave"		VDTReadBinaryWave2/P =$possiblyquotename(thePortName)/Q/O=(kE4050Sleep) IPB		if (kE4050debug)			PrintE4050OutPut()		endif		// Parse the wave		// look for first number		for (ii=10;ii < 50 && ((IBPWave [ii] < 47) || (IBPWave [ii] > 57)); ii+=1)		endfor		if (ii == 50)			print "E4050 failed to read the \"D\" PID value for the \"" + theAxis + "\" axis."			PIDd =Nan		else // read numeric characters (ASCII 48 to 57 into string			e4050inputStr = num2char (IBPWave [ii]) 			for (ii+=1;ii < 50 && ((IBPWave [ii] > 47) && (IBPWave [ii] < 58)); ii += 1)				e4050inputStr += num2char (IBPWave [ii])			endfor			readVal = str2num (e4050inputStr)			if (numtype (readVal) == 0)				dS = readval				PIDd = dS			else				dS =Nan				print"E4050 failed to read the \"D\" PID value for the \"" + theAxis + "\" axis. What was read was:", e4050inputStr			endif		endif	else		dS = Nan	endif	isBusy = 0end//*************************************************************************************************// Utility function to print output of E4050, as read into the IBP wave, to the command line// Last Modified Sep 13 by Jamie Boydfunction PrintE4050OutPut ()		WAVE/b/u outPut = root:packages:E4050:IBPwave	variable ii, nChars = numpnts (outPut)	for (ii =0; ii < nChars; ii +=1)		printf num2char (outPut [ii])	endfor	print "\r"end